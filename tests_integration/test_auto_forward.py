"""Integration tests for ssh-auto-forward.

These tests can use either:
1. A real SSH server (default: hetzner, override with SSH_AUTO_FORWARD_TEST_HOST)
2. A Docker container with SSH server (set SSH_AUTO_FORWARD_USE_DOCKER=1)

Requires Python 3.10+ and pytest.

NOTE: Integration tests require SSH access. Set SSH_AUTO_FORWARD_TEST_HOST to run:
    SSH_AUTO_FORWARD_TEST_HOST=your-server uv run pytest tests_integration/
"""

import os
import socket
import subprocess
import sys
import tempfile
import time
from typing import Generator

import pytest
import paramiko
from paramiko import SSHClient

# Default test host - can be overridden with SSH_AUTO_FORWARD_TEST_HOST
TEST_HOST = os.getenv("SSH_AUTO_FORWARD_TEST_HOST", None)

# Skip all tests if no SSH host is provided
if not TEST_HOST:
    pytest.skip("Skipping integration tests: SSH_AUTO_FORWARD_TEST_HOST not set", allow_module_level=True)

# Docker SSH container settings (default: use Docker)
# Set SSH_AUTO_FORWARD_USE_DOCKER=0 to use a real SSH server instead
USE_DOCKER = os.getenv("SSH_AUTO_FORWARD_USE_DOCKER", "0") == "1" and os.getenv("SSH_AUTO_FORWARD_TEST_HOST", "") == ""
DOCKER_SSH_IMAGE = "panubo/sshd:latest"
DOCKER_CONTAINER_NAME = "ssh-auto-forward-test"
DOCKER_SSH_USER = "root"
DOCKER_SSH_PASSWORD = "root"

# Custom SSH config path and key for Docker tests
_DOCKER_SSH_CONFIG_PATH = None
_DOCKER_SSH_PORT = None
_DOCKER_SSH_KEY_PATH = None


def find_free_port() -> int:
    """Find a free port on localhost."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("", 0))
        s.listen(1)
        port = s.getsockname()[1]
    return port


def generate_ssh_key() -> str:
    """Generate a temporary SSH key pair and return the private key path."""
    import paramiko.rsakey

    fd, private_key_path = tempfile.mkstemp(suffix="_ssh_test_key")
    os.close(fd)

    # Generate key using paramiko
    key = paramiko.RSAKey.generate(2048)
    key.write_private_key_file(private_key_path)

    # Write public key
    with open(private_key_path + ".pub", "w") as f:
        f.write(f"{key.get_name()} {key.get_base64()}")

    return private_key_path


def create_ssh_config_for_docker(port: int, key_path: str) -> str:
    """Create a custom SSH config file for Docker container."""
    global _DOCKER_SSH_CONFIG_PATH, _DOCKER_SSH_PORT, _DOCKER_SSH_KEY_PATH

    # Store paths and port
    _DOCKER_SSH_PORT = port
    _DOCKER_SSH_KEY_PATH = key_path

    # Create a temp file for SSH config
    fd, path = tempfile.mkstemp(suffix="_ssh_config")
    os.close(fd)

    config = f"""# Auto-generated by ssh-auto-forward integration tests
Host integration
    HostName 127.0.0.1
    Port {port}
    User {DOCKER_SSH_USER}
    IdentityFile {key_path}
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
"""

    with open(path, "w") as f:
        f.write(config)

    _DOCKER_SSH_CONFIG_PATH = path
    return path


def cleanup_ssh_config():
    """Remove the custom SSH config and keys."""
    global _DOCKER_SSH_CONFIG_PATH, _DOCKER_SSH_PORT, _DOCKER_SSH_KEY_PATH
    if _DOCKER_SSH_CONFIG_PATH and os.path.exists(_DOCKER_SSH_CONFIG_PATH):
        os.remove(_DOCKER_SSH_CONFIG_PATH)
    if _DOCKER_SSH_KEY_PATH and os.path.exists(_DOCKER_SSH_KEY_PATH):
        os.remove(_DOCKER_SSH_KEY_PATH)
        pub_key = _DOCKER_SSH_KEY_PATH + ".pub"
        if os.path.exists(pub_key):
            os.remove(pub_key)
    _DOCKER_SSH_CONFIG_PATH = None
    _DOCKER_SSH_PORT = None
    _DOCKER_SSH_KEY_PATH = None


def get_ssh_env() -> dict:
    """Get environment with SSH_CONFIG set for Docker tests."""
    env = os.environ.copy()
    if USE_DOCKER and _DOCKER_SSH_CONFIG_PATH:
        env["SSH_CONFIG"] = _DOCKER_SSH_CONFIG_PATH
    return env


def ssh_command(command: str, host: str = None) -> tuple[bool, str]:
    """Run a command on the remote server via SSH."""
    host = host or TEST_HOST
    if not host:
        return False, "No SSH host configured"

    cmd = ["ssh"]
    if USE_DOCKER and _DOCKER_SSH_CONFIG_PATH:
        cmd.extend(["-F", _DOCKER_SSH_CONFIG_PATH])
    cmd.append(host)
    cmd.append(command)

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            timeout=30,
        )
        return result.returncode == 0, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except Exception as e:
        return False, str(e)


def kill_remote_process(port: int, host: str = None):
    """Kill any process listening on the given port."""
    host = host or TEST_HOST
    if not host:
        return
    ssh_command(f"fuser -k {port}/tcp 2>/dev/null || true", host)
    ssh_command(f"pkill -f 'python.*http.server.*{port}' 2>/dev/null || true", host)
    ssh_command(f"pkill -f 'nc.*-l.*{port}' 2>/dev/null || true", host)


@pytest.fixture(scope="module")
def docker_ssh_server():
    """Start a Docker container with SSH server for testing.

    IMPORTANT: Only SSH port is exposed. Other ports are NOT accessible directly,
    which simulates a firewall scenario. The only way to reach them is via SSH forwarding.

    This is an autouse fixture when Docker is enabled - it will automatically run
    before any tests that need SSH access.
    """
    if not USE_DOCKER:
        yield None
        return

    # Check if Docker is available
    try:
        subprocess.run(["docker", "--version"], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("Docker not available")

    # Find a free port for SSH
    ssh_port = find_free_port()

    # Generate SSH key pair
    private_key_path = generate_ssh_key()
    with open(private_key_path + ".pub", "r") as f:
        public_key = f.read().strip()

    # Remove existing container if any
    subprocess.run(
        ["docker", "rm", "-f", DOCKER_CONTAINER_NAME],
        capture_output=True,
    )

    # Start new SSH container with public key as env var
    subprocess.run([
        "docker", "run", "-d",
        "--name", DOCKER_CONTAINER_NAME,
        "-p", f"{ssh_port}:22",  # Only SSH port exposed!
        "-e", f"PUBLIC_KEY={public_key}",
        "-e", "PASSWORD=root",
        DOCKER_SSH_IMAGE
    ], check=True)

    # Wait for SSH to be ready
    for _ in range(30):
        try:
            result = subprocess.run(
                ["docker", "exec", DOCKER_CONTAINER_NAME, "sh", "-c", "uptime"],
                capture_output=True,
                timeout=2,
            )
            if result.returncode == 0:
                break
        except (subprocess.TimeoutExpired, OSError):
            time.sleep(1)
    else:
        pytest.fail("Docker SSH server did not start in time")

    # Create custom SSH config with the generated key
    config_path = create_ssh_config_for_docker(ssh_port, private_key_path)

    # Return the host alias to use
    yield "integration"

    # Cleanup
    cleanup_ssh_config()
    subprocess.run(
        ["docker", "rm", "-f", DOCKER_CONTAINER_NAME],
        capture_output=True,
    )


# Autouse fixture that ensures docker_ssh_server runs when Docker is enabled
@pytest.fixture(scope="module", autouse=USE_DOCKER)
def auto_docker_ssh(docker_ssh_server):
    """Autouse fixture to ensure Docker SSH server is available when needed."""
    return docker_ssh_server


@pytest.fixture
def cleanup_remote_ports():
    """Kill test processes on remote before and after tests."""
    if not TEST_HOST:
        yield
        return

    host = "integration" if USE_DOCKER else TEST_HOST

    # Cleanup before
    for port in range(19000, 19020):
        kill_remote_process(port, host)
    yield
    # Cleanup after
    for port in range(19000, 19020):
        kill_remote_process(port, host)


def get_test_host():
    """Get the test host to use."""
    if not TEST_HOST:
        pytest.skip("Skipping test: SSH_AUTO_FORWARD_TEST_HOST not set")
    return "integration" if USE_DOCKER else TEST_HOST


class TestAutoForwardSamePort:
    """Test that forwarding works when local port is available."""

    def test_forward_to_same_port(self, cleanup_remote_ports):
        """Test that a remote port is forwarded to the same local port when available."""
        test_host = get_test_host()
        test_port = 19001

        # Verify local port is free
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(("127.0.0.1", test_port))
            except OSError:
                pytest.skip(f"Port {test_port} is busy locally")

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        try:
            # Run the forwarder
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=get_ssh_env()
            )

            # Wait for forwarding to start
            time.sleep(5)

            # Check if we can access the forwarded port
            import urllib.request
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=5) as response:
                    assert response.status == 200
            except urllib.error.URLError as e:
                pytest.fail(f"Failed to access forwarded port: {e}")

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            # Cleanup remote server
            kill_remote_process(test_port, test_host)


class TestAutoForwardPortBusy:
    """Test that forwarding works when local port is busy."""

    def test_forward_to_incremented_port(self, cleanup_remote_ports):
        """Test that a remote port is forwarded to incremented local port when original is busy."""
        test_host = get_test_host()
        test_port = 19002

        # Occupy the local port
        blocker = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        try:
            blocker.bind(("127.0.0.1", test_port))
            blocker.listen(1)

            # Start HTTP server on remote
            success, output = ssh_command(
                f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            assert success, f"Failed to start remote server: {output}"
            time.sleep(2)

            try:
                # Run the forwarder
                forwarder = subprocess.Popen(
                    [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True
                )

                # Wait for forwarding to start
                time.sleep(5)

                # The forwarder should have used port + 1
                local_port = test_port + 1
                try:
                    with urllib.request.urlopen(f"http://127.0.0.1:{local_port}/", timeout=5) as response:
                        assert response.status == 200
                except urllib.error.URLError as e:
                    pytest.fail(f"Failed to access forwarded port {local_port}: {e}")

            finally:
                forwarder.terminate()
                forwarder.wait(timeout=10)
                kill_remote_process(test_port, test_host)
        finally:
            blocker.close()


class TestAutoDetectAndCleanup:
    """Test auto-detection of new ports and cleanup of closed ports."""

    def test_auto_detect_new_port(self, cleanup_remote_ports):
        """Test that new ports are automatically detected and forwarded."""
        test_host = get_test_host()
        test_port = 19003

        # Run the forwarder first
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        time.sleep(3)

        try:
            # Start HTTP server on remote AFTER forwarder is running
            success, output = ssh_command(
                f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            assert success, f"Failed to start remote server: {output}"

            # Wait for auto-detection
            time.sleep(5)

            # Check if we can access the forwarded port
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=5) as response:
                    assert response.status == 200
            except urllib.error.URLError as e:
                pytest.fail(f"Failed to access auto-forwarded port: {e}")

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            kill_remote_process(test_port, test_host)

    def test_auto_cleanup_closed_port(self, cleanup_remote_ports):
        """Test that forwarding stops when remote port closes."""
        test_host = get_test_host()
        test_port = 19004

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        # Run the forwarder
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        time.sleep(3)

        try:
            # Verify forwarding works
            with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=5) as response:
                assert response.status == 200

            # Kill the remote server
            kill_remote_process(test_port, test_host)
            time.sleep(2)

            # Try to access again - should fail
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=2) as response:
                    pytest.fail("Port should no longer be accessible")
            except urllib.error.URLError:
                pass  # Expected

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)


class TestMultiplePorts:
    """Test forwarding multiple ports simultaneously."""

    def test_forward_multiple_ports(self, cleanup_remote_ports):
        """Test that multiple ports can be forwarded at once."""
        test_host = get_test_host()
        test_ports = [19005, 19006, 19007]

        # Start HTTP servers on remote
        for port in test_ports:
            success, output = ssh_command(
                f"python3 -m http.server {port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            assert success, f"Failed to start remote server on port {port}: {output}"
        time.sleep(2)

        try:
            # Run the forwarder
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=get_ssh_env()
            )
            time.sleep(5)

            # Check all ports are accessible
            for port in test_ports:
                try:
                    with urllib.request.urlopen(f"http://127.0.0.1:{port}/", timeout=5) as response:
                        assert response.status == 200
                except urllib.error.URLError as e:
                    pytest.fail(f"Failed to access forwarded port {port}: {e}")

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            for port in test_ports:
                kill_remote_process(port, test_host)


class TestSkipList:
    """Test port skip list functionality."""

    def test_skip_well_known_ports(self, cleanup_remote_ports):
        """Test that well-known ports (< 1000) are skipped by default."""
        test_host = get_test_host()

        # Start server on port 80 (should be skipped)
        success, output = ssh_command(
            "python3 -m http.server 80 --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        # This might fail due to permissions, that's okay
        if not success:
            pytest.skip("Could not start server on port 80")

        time.sleep(2)

        try:
            # Run the forwarder
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=get_ssh_env()
            )
            time.sleep(5)

            # Port 80 should NOT be forwarded
            try:
                with urllib.request.urlopen("http://127.0.0.1:80/", timeout=2) as response:
                    pytest.fail("Port 80 should have been skipped")
            except urllib.error.URLError:
                pass  # Expected - port should not be forwarded

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            kill_remote_process(80, test_host)

    def test_forward_custom_skip_list(self, cleanup_remote_ports):
        """Test custom skip list."""
        test_host = get_test_host()
        test_port = 19008

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        try:
            # Run the forwarder with custom skip list (skip our test port)
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-s", str(test_port)],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                env=get_ssh_env()
            )
            time.sleep(5)

            # Port should be skipped (not forwarded)
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=2) as response:
                    pytest.fail(f"Port {test_port} should have been skipped")
            except urllib.error.URLError:
                pass  # Expected - port should be skipped

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            kill_remote_process(test_port, test_host)


class TestConnectionHandling:
    """Test connection failure handling."""

    def test_connection_failure_handling(self):
        """Test that connection failures are handled gracefully."""
        # Use a non-existent host
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", "nonexistent-host-test-12345", "--cli"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            env=get_ssh_env()
        )

        try:
            stdout, stderr = forwarder.communicate(timeout=30)
            # Should fail gracefully, not hang
            assert forwarder.returncode != 0
            assert "Failed to connect" in stderr or "Could not resolve" in stderr
        except subprocess.TimeoutExpired:
            forwarder.kill()
            pytest.fail("Process should have exited on connection failure")


class TestPortRemapping:
    """Test port remapping when local ports are busy."""

    def test_multiple_increment_when_many_ports_busy(self, cleanup_remote_ports):
        """Test that ports increment multiple times when many local ports are busy."""
        test_host = get_test_host()
        remote_port = 19009

        # Occupy several local ports
        occupied_ports = []
        for i in range(5):
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                s.bind(("127.0.0.1", remote_port + i))
                s.listen(1)
                occupied_ports.append(s)
            except OSError:
                break

        try:
            # Start HTTP server on remote
            success, output = ssh_command(
                f"python3 -m http.server {remote_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            assert success, f"Failed to start remote server: {output}"
            time.sleep(2)

            # Run the forwarder
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            time.sleep(5)

            # Find the forwarded port
            expected_local = remote_port + len(occupied_ports)
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{expected_local}/", timeout=5) as response:
                    assert response.status == 200
            except urllib.error.URLError:
                # Check output for what port was actually used
                forwarder.terminate()
                stdout, stderr = forwarder.communicate()
                pytest.fail(f"Expected port {expected_local} to be forwarded. Output: {stderr}")

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            for s in occupied_ports:
                s.close()
            kill_remote_process(remote_port, test_host)


class TestHighNumberedPorts:
    """Test behavior with high-numbered ports (above max-auto-port)."""

    def test_forward_high_port(self, cleanup_remote_ports):
        """Test that high ports can be manually forwarded."""
        test_host = get_test_host()
        test_port = 15000  # Above default max_auto_port of 10000

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        try:
            # Run the forwarder with higher max-auto-port
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            time.sleep(5)

            # Port should be forwarded (since we set max-auto-port to 20000)
            try:
                with urllib.request.urlopen(f"http://127.0.0.1:{test_port}/", timeout=5) as response:
                    assert response.status == 200
            except urllib.error.URLError as e:
                pytest.fail(f"Failed to access high port {test_port}: {e}")

        finally:
            forwarder.terminate()
            forwarder.wait(timeout=10)
            kill_remote_process(test_port, test_host)


class TestDashboardAutoForward:
    """Test dashboard mode functionality."""

    def test_dashboard_imports(self):
        """Test that dashboard module can be imported."""
        from ssh_auto_forward.dashboard import DashboardApp, TunnelDataTable, LogHandler, LogPanel
        assert DashboardApp is not None
        assert TunnelDataTable is not None
        assert LogHandler is not None
        assert LogPanel is not None

    def test_dashboard_auto_forwards_ports(self, cleanup_remote_ports):
        """Test that the dashboard mode automatically forwards ports."""
        test_host = get_test_host()
        test_port = 19010

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        # We can't actually run the interactive dashboard in tests,
        # but we can verify that the forwarder connects and scans
        # For now, just verify the module imports and basic setup works
        from ssh_auto_forward.forwarder import SSHAutoForwarder

        forwarder = SSHAutoForwarder(
            host_alias=test_host,
            scan_interval=3,
            max_auto_port=20000,
        )

        # Verify config was loaded
        assert forwarder.config is not None
        assert forwarder.host_alias == test_host

        kill_remote_process(test_port, test_host)
