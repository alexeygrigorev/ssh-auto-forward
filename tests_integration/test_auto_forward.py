"""Integration tests for ssh-auto-forward.

These tests can use either:
1. A real SSH server (default: hetzner, override with SSH_AUTO_FORWARD_TEST_HOST)
2. A Docker container with SSH server (set SSH_AUTO_FORWARD_USE_DOCKER=1)

Requires Python 3.10+ and pytest.
"""

import os
import socket
import subprocess
import sys
import time
from typing import Generator

import pytest
import paramiko
from paramiko import SSHClient

# Default test host - can be overridden with SSH_AUTO_FORWARD_TEST_HOST
TEST_HOST = os.getenv("SSH_AUTO_FORWARD_TEST_HOST", "hetzner")

# Docker SSH container settings (default: use Docker)
# Set SSH_AUTO_FORWARD_USE_DOCKER=0 to use a real SSH server instead
USE_DOCKER = os.getenv("SSH_AUTO_FORWARD_USE_DOCKER", "1") == "1" and os.getenv("SSH_AUTO_FORWARD_TEST_HOST", "") == ""
DOCKER_SSH_IMAGE = "panubo/sshd:latest"
DOCKER_CONTAINER_NAME = "ssh-auto-forward-test"
DOCKER_SSH_USER = "root"
DOCKER_SSH_PASSWORD = "root"


def find_free_port() -> int:
    """Find a free port on localhost."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(("", 0))
        s.listen(1)
        port = s.getsockname()[1]
    return port


def setup_ssh_config_for_docker(port: int):
    """Add SSH config entry for Docker container."""
    ssh_config_path = os.path.expanduser("~/.ssh/config")
    backup_path = os.path.expanduser("~/.ssh/config.bak")

    # Backup existing config
    if os.path.exists(ssh_config_path):
        with open(ssh_config_path, "r") as f:
            original_content = f.read()
        with open(backup_path, "w") as f:
            f.write(original_content)

    # Read existing config
    config_content = ""
    if os.path.exists(ssh_config_path):
        with open(ssh_config_path, "r") as f:
            config_content = f.read()

    # Remove old integration host if exists
    lines = []
    skip_next = False
    for line in config_content.split("\n"):
        if line.strip() == "Host integration":
            skip_next = True
            continue
        if skip_next:
            if line and not line.startswith(" "):
                skip_next = False
            else:
                continue
        lines.append(line)

    # Add integration host
    new_config = "\n".join(lines)
    new_config += f"""

# Auto-generated by ssh-auto-forward integration tests
Host integration
    HostName 127.0.0.1
    Port {port}
    User {DOCKER_SSH_USER}
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
"""

    with open(ssh_config_path, "w") as f:
        f.write(new_config)


def restore_ssh_config():
    """Restore original SSH config after Docker tests."""
    ssh_config_path = os.path.expanduser("~/.ssh/config")
    backup_path = os.path.expanduser("~/.ssh/config.bak")

    if os.path.exists(backup_path):
        with open(backup_path, "r") as f:
            original_content = f.read()
        with open(ssh_config_path, "w") as f:
            f.write(original_content)
        os.remove(backup_path)


def ssh_command(command: str, host: str = None) -> tuple[bool, str]:
    """Run a command on the remote server via SSH."""
    host = host or TEST_HOST
    try:
        result = subprocess.run(
            ["ssh", host, command],
            capture_output=True,
            text=True,
            timeout=30,
        )
        return result.returncode == 0, result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return False, "Command timed out"
    except Exception as e:
        return False, str(e)


def kill_remote_process(port: int, host: str = None):
    """Kill any process listening on the given port."""
    host = host or TEST_HOST
    ssh_command(f"fuser -k {port}/tcp 2>/dev/null || true", host)
    ssh_command(f"pkill -f 'python.*http.server.*{port}' 2>/dev/null || true", host)
    ssh_command(f"pkill -f 'nc.*-l.*{port}' 2>/dev/null || true", host)


@pytest.fixture(scope="module")
def docker_ssh_server():
    """Start a Docker container with SSH server for testing.

    IMPORTANT: Only SSH port is exposed. Other ports are NOT accessible directly,
    which simulates a firewall scenario. The only way to reach them is via SSH forwarding.
    """
    if not USE_DOCKER:
        yield None
        return

    # Check if Docker is available
    try:
        subprocess.run(["docker", "--version"], check=True, capture_output=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        pytest.skip("Docker not available")

    # Find a free port for SSH
    ssh_port = find_free_port()

    # Remove existing container if any
    subprocess.run(
        ["docker", "rm", "-f", DOCKER_CONTAINER_NAME],
        capture_output=True,
    )

    # Start new SSH container - ONLY expose SSH port
    subprocess.run([
        "docker", "run", "-d",
        "--name", DOCKER_CONTAINER_NAME,
        "-p", f"{ssh_port}:22",  # Only SSH port exposed!
        "-e", f"SSH_PASSWORD={DOCKER_SSH_PASSWORD}",
        DOCKER_SSH_IMAGE
    ], check=True)

    # Wait for SSH to be ready
    for _ in range(30):
        try:
            with socket.create_connection(("127.0.0.1", ssh_port), timeout=1):
                break
        except (OSError, socket.timeout):
            time.sleep(1)
    else:
        pytest.fail("Docker SSH server did not start in time")

    # Setup SSH config
    setup_ssh_config_for_docker(ssh_port)

    # Return the host alias to use
    yield "integration"

    # Cleanup
    restore_ssh_config()
    subprocess.run(
        ["docker", "rm", "-f", DOCKER_CONTAINER_NAME],
        capture_output=True,
    )


@pytest.fixture
def cleanup_remote_ports():
    """Kill test processes on remote before and after tests."""
    host = "integration" if USE_DOCKER else TEST_HOST

    # Cleanup before
    for port in range(19000, 19020):
        kill_remote_process(port, host)
    yield
    # Cleanup after
    for port in range(19000, 19020):
        kill_remote_process(port, host)


def get_test_host():
    """Get the test host to use."""
    return "integration" if USE_DOCKER else TEST_HOST


class TestAutoForwardSamePort:
    """Test that forwarding works when local port is available."""

    def test_forward_to_same_port(self, cleanup_remote_ports):
        """Test that a remote port is forwarded to the same local port when available."""
        test_host = get_test_host()
        test_port = 19001

        # Verify local port is free
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(("127.0.0.1", test_port))
            except OSError:
                pytest.skip(f"Port {test_port} is busy locally")

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        # Start the forwarder
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            # Wait for forwarder to detect the port
            max_wait = 15
            for i in range(max_wait):
                time.sleep(1)
                try:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        s.connect(("127.0.0.1", test_port))
                        s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                        response = s.recv(100)
                        if b"HTTP" in response or b"Directory" in response or b"200 OK" in response:
                            break
                except (OSError, ConnectionRefusedError, socket.timeout):
                    continue
            else:
                pytest.fail(f"Port {test_port} was not forwarded within {max_wait} seconds")

            # Verify forwarder is still running
            assert forwarder.poll() is None, "Forwarder exited unexpectedly"

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)


class TestAutoForwardPortBusy:
    """Test that forwarding increments when local port is busy."""

    def test_forward_to_incremented_port(self, cleanup_remote_ports):
        """Test that a remote port is forwarded to incremented port when local port is busy."""
        test_host = get_test_host()
        test_port = 19002

        # Start a local server to occupy the port
        local_server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        local_server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        try:
            local_server.bind(("127.0.0.1", test_port))
            local_server.listen(1)

            # Start HTTP server on remote
            ssh_command(
                f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            time.sleep(2)

            # Start the forwarder
            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            try:
                time.sleep(5)

                # Try incremented ports
                connected = False
                for offset in range(1, 10):
                    try:
                        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                            s.settimeout(1)
                            s.connect(("127.0.0.1", test_port + offset))
                            s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                            response = s.recv(100)
                            if b"HTTP" in response or b"Directory" in response or b"200 OK" in response:
                                connected = True
                                break
                    except (OSError, ConnectionRefusedError, socket.timeout):
                        continue

                assert connected, "Could not connect to forwarded port on any increment"

            finally:
                forwarder.terminate()
                try:
                    forwarder.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    forwarder.kill()
                kill_remote_process(test_port, test_host)

        finally:
            local_server.close()


class TestAutoDetectAndCleanup:
    """Test auto-detection of new ports and cleanup of closed ports."""

    def test_auto_detect_new_port(self, cleanup_remote_ports):
        """Test that a new port is automatically detected and forwarded."""
        test_host = get_test_host()
        test_port = 19004

        # Start the forwarder first
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(3)  # Let it do initial scan

            # Now start a server on remote
            ssh_command(
                f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            time.sleep(6)  # Give it time to be detected

            # Try to connect
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect(("127.0.0.1", test_port))
                s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                response = s.recv(100)
                assert b"HTTP" in response or b"Directory" in response or b"200 OK" in response

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)

    def test_auto_cleanup_closed_port(self, cleanup_remote_ports):
        """Test that a tunnel is cleaned up when remote port closes."""
        test_host = get_test_host()
        test_port = 19005

        # Start a server on remote
        ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        time.sleep(2)

        # Start the forwarder
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(5)

            # Verify it's forwarded
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(2)
                s.connect(("127.0.0.1", test_port))

            # Kill the remote server
            kill_remote_process(test_port, test_host)
            time.sleep(6)  # Give time for cleanup

            # Verify the tunnel was closed
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    s.connect(("127.0.0.1", test_port))
            except (OSError, ConnectionRefusedError, socket.timeout):
                # This is expected - the tunnel was cleaned up
                pass

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)


class TestMultiplePorts:
    """Test handling multiple ports simultaneously."""

    def test_forward_multiple_ports(self, cleanup_remote_ports):
        """Test forwarding multiple ports at once."""
        test_host = get_test_host()
        test_ports = [19010, 19011, 19012]

        # Start multiple servers on remote
        for port in test_ports:
            ssh_command(
                f"python3 -m http.server {port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
        time.sleep(2)

        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(6)

            # Verify all ports are forwarded
            for port in test_ports:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(2)
                    s.connect(("127.0.0.1", port))
                    s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                    response = s.recv(100)
                    assert b"HTTP" in response or b"Directory" in response or b"200 OK" in response, \
                        f"Port {port} not forwarded"

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            for port in test_ports:
                kill_remote_process(port, test_host)


class TestSkipList:
    """Test skip list functionality."""

    def test_skip_well_known_ports(self, cleanup_remote_ports):
        """Test that well-known ports (< 1000) are skipped by default."""
        test_host = get_test_host()
        test_port = 888

        # Start server on remote
        ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        time.sleep(2)

        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(5)

            # Port should NOT be forwarded (skipped by default)
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    s.connect(("127.0.0.1", test_port))
            except (OSError, ConnectionRefusedError, socket.timeout):
                # This is expected - port should not be forwarded
                pass

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)

    def test_forward_custom_skip_list(self, cleanup_remote_ports):
        """Test custom skip list."""
        test_host = get_test_host()
        test_port = 19013

        # Start server on remote
        ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        time.sleep(2)

        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "-i", "3", "-s", str(test_port)],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(5)

            # Port should NOT be forwarded (in custom skip list)
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(1)
                    s.connect(("127.0.0.1", test_port))
            except (OSError, ConnectionRefusedError, socket.timeout):
                # Expected - port should be skipped
                pass

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)


class TestConnectionHandling:
    """Test connection handling and error cases."""

    def test_connection_failure_handling(self):
        """Test that forwarder handles connection failures gracefully."""
        # Use a non-existent host
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", "nonexistent-host-99999"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            # Wait for connection attempt
            time.sleep(10)

            # Should have exited due to connection failure
            forwarder.poll()
            if forwarder.returncode is not None:
                stdout, stderr = forwarder.communicate()
                assert "Connection failed" in stderr or "not resolve" in stderr.lower()
        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()


class TestPortRemapping:
    """Test port remapping in various scenarios."""

    def test_multiple_increment_when_many_ports_busy(self, cleanup_remote_ports):
        """Test that port increments multiple times when several local ports are busy."""
        test_host = get_test_host()
        test_port = 19014
        busy_ports = [test_port, test_port + 1, test_port + 2]

        # Occupy local ports
        servers = []
        for port in busy_ports:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            s.bind(("127.0.0.1", port))
            s.listen(1)
            servers.append(s)

        try:
            # Start server on remote
            ssh_command(
                f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
                host=test_host
            )
            time.sleep(2)

            forwarder = subprocess.Popen(
                [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
            )

            try:
                time.sleep(5)

                # Should be forwarded to port + 3 (since first 3 are busy)
                connected = False
                for offset in range(3, 10):
                    try:
                        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                            s.settimeout(1)
                            s.connect(("127.0.0.1", test_port + offset))
                            s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                            response = s.recv(100)
                            if b"HTTP" in response or b"Directory" in response or b"200 OK" in response:
                                connected = True
                                break
                    except (OSError, ConnectionRefusedError, socket.timeout):
                        continue

                assert connected, "Could not connect to forwarded port after multiple increments"

            finally:
                forwarder.terminate()
                try:
                    forwarder.wait(timeout=5)
                except subprocess.TimeoutExpired:
                    forwarder.kill()
                kill_remote_process(test_port, test_host)

        finally:
            for s in servers:
                s.close()


class TestHighNumberedPorts:
    """Test forwarding of high-numbered ports."""

    def test_forward_high_port(self, cleanup_remote_ports):
        """Test forwarding a high-numbered port (> 30000)."""
        test_host = get_test_host()
        test_port = 45000

        # Start server on remote
        ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        time.sleep(2)

        # Use -m 50000 to allow auto-forwarding of high ports
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "50000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            time.sleep(6)

            # Should be forwarded to same port if available
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                    s.settimeout(2)
                    s.connect(("127.0.0.1", test_port))
                    s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                    response = s.recv(100)
                    assert b"HTTP" in response or b"Directory" in response or b"200 OK" in response
            except (OSError, ConnectionRefusedError, socket.timeout) as e:
                # Might be incremented if port is busy
                try:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(2)
                        s.connect(("127.0.0.1", test_port + 1))
                        s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                        response = s.recv(100)
                        assert b"HTTP" in response or b"Directory" in response or b"200 OK" in response
                except (OSError, ConnectionRefusedError, socket.timeout):
                    pytest.fail(f"High port {test_port} was not forwarded: {e}")

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)


class TestDashboardAutoForward:
    """Test that dashboard mode auto-forwards ports."""

    def test_dashboard_imports(self):
        """Test that dashboard module can be imported."""
        from ssh_auto_forward.dashboard import DashboardApp, TunnelDataTable, LogHandler, LogPanel
        assert DashboardApp is not None
        assert TunnelDataTable is not None
        assert LogHandler is not None
        assert LogPanel is not None

    def test_dashboard_auto_forwards_ports(self, cleanup_remote_ports):
        """Test that the dashboard mode automatically forwards ports."""
        test_host = get_test_host()
        test_port = 19020

        # Verify local port is free
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            try:
                s.bind(("127.0.0.1", test_port))
            except OSError:
                pytest.skip(f"Port {test_port} is busy locally")

        # Start HTTP server on remote
        success, output = ssh_command(
            f"python3 -m http.server {test_port} --bind 127.0.0.1 > /dev/null 2>&1 &",
            host=test_host
        )
        assert success, f"Failed to start remote server: {output}"
        time.sleep(2)

        # Start the forwarder (using --cli for testing, but dashboard logic is same)
        forwarder = subprocess.Popen(
            [sys.executable, "-m", "ssh_auto_forward.cli", test_host, "--cli", "-i", "3", "-m", "20000"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
        )

        try:
            # Wait for forwarder to detect the port
            max_wait = 15
            for i in range(max_wait):
                time.sleep(1)
                try:
                    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                        s.settimeout(1)
                        s.connect(("127.0.0.1", test_port))
                        s.sendall(b"GET / HTTP/1.0\r\n\r\n")
                        response = s.recv(100)
                        if b"HTTP" in response or b"Directory" in response or b"200 OK" in response:
                            break
                except (OSError, ConnectionRefusedError, socket.timeout):
                    continue
            else:
                pytest.fail(f"Port {test_port} was not forwarded within {max_wait} seconds")

            # Verify forwarder is still running
            assert forwarder.poll() is None, "Forwarder exited unexpectedly"

        finally:
            forwarder.terminate()
            try:
                forwarder.wait(timeout=5)
            except subprocess.TimeoutExpired:
                forwarder.kill()
            kill_remote_process(test_port, test_host)
